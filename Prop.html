<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Prop: 命题与证据</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Prop<span class="subtitle">命题与证据</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">Logic</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab230"></a><h1 class="section">归纳定义命题</h1>

<div class="paragraph"> </div>

 在<span class="inlinecode"><span class="id" type="var">Basics</span></span>一章中，我们定义了一个用来检测一个数字是否为偶数的 <i>函数</i> <span class="inlinecode"><span class="id" type="var">evenb</span></span>，
    若为偶数这个函数将返回<span class="inlinecode"><span class="id" type="var">true</span></span>。我们能够用这个函数来定义宣称某个数字<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数的 <i>命题</i> ： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">even</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">evenb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
也即是说，我们能够将“<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数”定义成“函数<span class="inlinecode"><span class="id" type="var">evenb</span></span>在被应用到<span class="inlinecode"><span class="id" type="var">n</span></span>上时返回<span class="inlinecode"><span class="id" type="var">true</span></span>”。

<div class="paragraph"> </div>

    注意，这里我们使用了一个<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>来为一个命题赋予一个名字，就像之前我
    们将名字赋予其他类型的表达式一样。这不是一种全新的命题；这仅仅是一条等式。
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    另外一个选择是直接定义出偶数这一概念。作为通过<span class="inlinecode"><span class="id" type="var">evenb</span></span>函数做出定义（“若对
    某个数计算得到<span class="inlinecode"><span class="id" type="var">true</span></span>，则这个数是偶数”）的替代，我们能够通过给出两种不
    同的展现某个数是偶数的 <i>证据</i> 的方式来说明偶数的概念。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">ev</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">ev_0</span> : <span class="id" type="var">ev</span> <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ev_SS</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, <span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
第一行声明了<span class="inlinecode"><span class="id" type="var">ev</span></span>是一个命题——或者更为形式化地说，一个与自然数“一一对应”
    的命题的集合（也即是说，对于每一个数字<span class="inlinecode"><span class="id" type="var">n</span></span>，陈述“<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数”是一个命
    题）。这样的命题所组成的集合通常被称作数字的 <i>性质</i> 。

<div class="paragraph"> </div>

    最后两行定义了给出证明某个数字<span class="inlinecode"><span class="id" type="var">m</span></span>是偶数的证据的方式。首先<span class="inlinecode">0</span>是偶数，而<span class="inlinecode"><span class="id" type="var">ev_0</span></span>
    则是这一事实的证据；第二，如果有<span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>且我们能够给出证明<span class="inlinecode"><span class="id" type="var">n</span></span>为偶数的
    证据<span class="inlinecode"><span class="id" type="var">e</span></span>，那么<span class="inlinecode"><span class="id" type="var">m</span></span>也是偶数，且<span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span>是这一事实的证据。

<div class="paragraph"> </div>

<a name="lab231"></a><h4 class="section">Exercise: 1 star (double_even)</h4>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_even</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> (<span class="id" type="var">double</span> <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>

<br/>
</div>

<div class="doc">
对于<span class="inlinecode"><span class="id" type="var">ev</span></span>，我们已经定义了函数<span class="inlinecode"><span class="id" type="var">even</span></span>（返回一个布尔值），然后又定义了一个能够
   表示它的归纳性关系。然而我们并不一定需要首先将命题当作布尔值函数来看
   待；我们可以直接思考能够表示它的归纳定义。

<div class="paragraph"> </div>

 作为归纳定义命题的另外一个例子，让我们定义一个简单的自然数的性质——
    我们将它称作"<span class="inlinecode"><span class="id" type="var">beautiful</span></span>"。
<div class="paragraph"> </div>

 非形式地说，如果某个数字是<span class="inlinecode">0</span>、<span class="inlinecode">3</span>、<span class="inlinecode">5</span>或者两个<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的数字的和，那么它是
    <span class="inlinecode"><span class="id" type="var">beautiful</span></span>的。

<div class="paragraph"> </div>

    更为准确地说，通过给出四条规则，我们能够定义<span class="inlinecode"><span class="id" type="var">beautiful</span></span>数：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 规则<span class="inlinecode"><span class="id" type="var">b_0</span></span>：<span class="inlinecode">0</span>是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的。

</li>
<li> 规则<span class="inlinecode"><span class="id" type="var">b_3</span></span>：<span class="inlinecode">3</span>是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的。

</li>
<li> 规则<span class="inlinecode"><span class="id" type="var">b_5</span></span>：<span class="inlinecode">5</span>是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的。

</li>
<li> 规则<span class="inlinecode"><span class="id" type="var">b_sum</span></span>：如果<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>都是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的，那么它们的和也是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的。
</li>
</ul>

<div class="paragraph"> </div>

 我们会在接下来的课程中看到许多像这样的定义，因此一个使得这些定义易于读
    写的轻便的表示法将会使非形式化的讨论变得更加方便。 <i>推理规则</i> 就是这一类
    表示法的其中一种：
<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (b_0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">beautiful&nbsp;0</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (b_3) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">beautiful&nbsp;3</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (b_5) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">beautiful&nbsp;5</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">beautiful&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beautiful&nbsp;m</td>
  <td class="infrulenamecol" rowspan="3">
    (b_sum) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">beautiful&nbsp;(n+m)</td>
  <td></td>
</td>
</table></center>
<div class="paragraph"> </div>

<a name="lab232"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

    以上的每一条用文字描述的规则在这里都被重排为一条推理规则；这种描述方式
    意欲表达的解读是：如果在横线上方的所有 <i>前提</i> 都成立，那么在横线下方的
     <i>结论</i> 成立。举例而言，规则<span class="inlinecode"><span class="id" type="var">b_sum</span></span>说明如果<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>都有beautiful这一性质，
    那么<span class="inlinecode"><span class="id" type="var">n</span>+<span class="id" type="var">m</span></span>也拥有这一性质。如果一个规则没有在横线之上的前提，那么它的结论
    无条件成立。

<div class="paragraph"> </div>

    这些规则 <i>定义</i> 了<span class="inlinecode"><span class="id" type="var">beautiful</span></span>这个性质。也就是说，如果我们想要说服某人某个
    数字<span class="inlinecode"><span class="id" type="var">beautiful</span></span>，那么我们的推理必须基于这些规则。举个简单的例子：
    假设我们宣称数字<span class="inlinecode">5</span>拥有性质<span class="inlinecode"><span class="id" type="var">beautiful</span></span>，为了证明它我们只需要指出规则<span class="inlinecode"><span class="id" type="var">b_5</span></span>
    中声明了这一点；或者假设我们希望证明<span class="inlinecode">8</span>拥有这个性质，为了证明它，在首先观察到<span class="inlinecode">3</span>和
    <span class="inlinecode">5</span>都是<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的（来自规则<span class="inlinecode"><span class="id" type="var">b_3</span></span>和<span class="inlinecode"><span class="id" type="var">b_5</span></span>）之后，我们能够通过规则
    <span class="inlinecode"><span class="id" type="var">b_sum</span></span>指出<span class="inlinecode">8</span>作为拥有这一特性的<span class="inlinecode">3</span>和<span class="inlinecode">5</span>的和拥有这一特性。这一推论能够通过下面的
    <i>证明树</i> 这一形式图形化地表示出来：
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------&nbsp;(<span class="id" type="var">b_3</span>)&nbsp;&nbsp;&nbsp;-----------&nbsp;(<span class="id" type="var">b_5</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------&nbsp;(<span class="id" type="var">b_sum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;8&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</div>
<a name="lab233"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

    当然也存在其他的使用这些规则证明这一事实的方法，比如说这一个证明：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------&nbsp;(<span class="id" type="var">b_5</span>)&nbsp;&nbsp;&nbsp;-----------&nbsp;(<span class="id" type="var">b_3</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------&nbsp;(<span class="id" type="var">b_sum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beautiful</span>&nbsp;8&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<a name="lab234"></a><h4 class="section">Exercise: 1 star (varieties_of_beauty)</h4>
 有多少种不同的证明<span class="inlinecode"><span class="id" type="var">beautiful</span></span> <span class="inlinecode">8</span>的方式？ 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab235"></a><h2 class="section">构建证据</h2>

<div class="paragraph"> </div>

 在Coq中，我们能够用如下的代码表示<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的定义：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">beautiful</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">b_0</span>   : <span class="id" type="var">beautiful</span> 0<br/>
| <span class="id" type="var">b_3</span>   : <span class="id" type="var">beautiful</span> 3<br/>
| <span class="id" type="var">b_5</span>   : <span class="id" type="var">beautiful</span> 5<br/>
| <span class="id" type="var">b_sum</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab236"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

    以这种方式引进的规则与已被证明的定理有着相同的地位；也就是说这些规则
    像公理一样不证自立，因此我们能够使用策略<span class="inlinecode"><span class="id" type="tactic">apply</span></span>和这些规则的名字来证明某
    些特定的数字拥有<span class="inlinecode"><span class="id" type="var">beautiful</span></span>这一性质。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">three_is_beautiful</span>: <span class="id" type="var">beautiful</span> 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;这能够直接从<span class="inlinecode"><span class="id" type="var">b_3</span></span>得出。*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_3</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">eight_is_beautiful</span>: <span class="id" type="var">beautiful</span> 8.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;首先我们使用规则<span class="inlinecode"><span class="id" type="var">b_sum</span></span>来让Coq知道如何将<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>实例化。*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_sum</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">n</span>:=3) (<span class="id" type="var">m</span>:=5).<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;为了证明<span class="inlinecode"><span class="id" type="var">b_sum</span></span>生成的子目标，我们必须提供<span class="inlinecode"><span class="id" type="var">beautiful</span></span> <span class="inlinecode">3</span>和<span class="inlinecode"><span class="id" type="var">beautiful</span></span> <span class="inlinecode">5</span>的<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证据。幸运的是我们有能够得出它们的规则。*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_3</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_5</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab237"></a><h3 class="section"> </h3>
 就像你会期待的那样，我们也能够证明包含有关<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的前提的定理。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beautiful_plus_eight</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> (8+<span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_sum</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">n</span>:=8) (<span class="id" type="var">m</span>:=<span class="id" type="var">n</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eight_is_beautiful</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab238"></a><h4 class="section">Exercise: 2 stars (b_times2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">b_times2</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> (2×<span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab239"></a><h4 class="section">Exercise: 3 stars (b_timesm)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">b_timesm</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> (<span class="id" type="var">m</span>×<span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab240"></a><h1 class="section">在证明中使用证据</h1>
<a name="lab241"></a><h2 class="section">针对证据的归纳法</h2>

<div class="paragraph"> </div>

 除了 <i>构造</i> 某些数字是beautiful的证据以外，我们还能够对这些证据
     <i>进行推理</i> 。
<div class="paragraph"> </div>

 我们用<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>定义引入了<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的这一事实在向Coq声明了<span class="inlinecode"><span class="id" type="var">b_0</span></span>、<span class="inlinecode"><span class="id" type="var">b_3</span></span>、
    <span class="inlinecode"><span class="id" type="var">b_5</span></span>以及<span class="inlinecode"><span class="id" type="var">b_sum</span></span>是构造证据的方式的同时也声明了这四个构造子是构造能够证实某
    个数字拥有beautiful这一性质的证据的 <i>唯一</i> 的方法。
<div class="paragraph"> </div>

 也就是说，如果有人给出了断言<span class="inlinecode"><span class="id" type="var">beautiful</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>的证据<span class="inlinecode"><span class="id" type="var">E</span></span>，那么我们可以知道
    <span class="inlinecode"><span class="id" type="var">E</span></span>一定有着下面四种形式中的其中一种：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">E</span></span>是<span class="inlinecode"><span class="id" type="var">b_0</span></span>，且<span class="inlinecode"><span class="id" type="var">n</span></span>为<span class="inlinecode">0</span>；

</li>
<li> <span class="inlinecode"><span class="id" type="var">E</span></span>是<span class="inlinecode"><span class="id" type="var">b_3</span></span>，且<span class="inlinecode"><span class="id" type="var">n</span></span>为<span class="inlinecode">3</span>；

</li>
<li> <span class="inlinecode"><span class="id" type="var">E</span></span>是<span class="inlinecode"><span class="id" type="var">b_5</span></span>，且<span class="inlinecode"><span class="id" type="var">n</span></span>为<span class="inlinecode">5</span>；

</li>
<li> <span class="inlinecode"><span class="id" type="var">E</span></span>是<span class="inlinecode"><span class="id" type="var">b_sum</span></span> <span class="inlinecode"><span class="id" type="var">n1</span></span> <span class="inlinecode"><span class="id" type="var">n2</span></span> <span class="inlinecode"><span class="id" type="var">E1</span></span> <span class="inlinecode"><span class="id" type="var">E2</span></span>，其中<span class="inlinecode"><span class="id" type="var">n</span></span>为<span class="inlinecode"><span class="id" type="var">n1</span>+<span class="id" type="var">n2</span></span>，<span class="inlinecode"><span class="id" type="var">E1</span></span>是证明<span class="inlinecode"><span class="id" type="var">n1</span></span>beautiful
        的证据，<span class="inlinecode"><span class="id" type="var">E2</span></span>是证明<span class="inlinecode"><span class="id" type="var">n2</span></span>beautiful的证据。
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab242"></a><h3 class="section"> </h3>
 这允许我们使用我们已经知道的证明策略对任何有着<span class="inlinecode"><span class="id" type="var">beautiful</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>形式的前提进
    行 <i>分析</i> 以知道这些前提是怎样构造的。具体地说，我们能够用之前我们已经看
    到被用在对归纳定义的<i>数据</i> 进行推理的<span class="inlinecode"><span class="id" type="tactic">induction</span></span>策略来对归纳定义的 <i>证据</i> 进
    行推理。

<div class="paragraph"> </div>

    为了说明这一点，让我们来定义另外一种数字的性质：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">gorgeous</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">g_0</span> : <span class="id" type="var">gorgeous</span> 0<br/>
| <span class="id" type="var">g_plus3</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> (3+<span class="id" type="var">n</span>)<br/>
| <span class="id" type="var">g_plus5</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> (5+<span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab243"></a><h4 class="section">Exercise: 1 star (gorgeous_tree)</h4>
 使用推理规则的表示法写出<span class="inlinecode"><span class="id" type="var">gorgeous</span></span>数字的定义。

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab244"></a><h4 class="section">Exercise: 1 star (gorgeous_plus13)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">gorgeous_plus13</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> (13+<span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab245"></a><h3 class="section"> </h3>
 就直观上而言这看上去十分明显：即使<span class="inlinecode"><span class="id" type="var">gorgeous</span></span>和<span class="inlinecode"><span class="id" type="var">beautiful</span></span>是由稍微有些不同
    的两组规则表示的，它们实际上说明了同一种性质：拥有前者的数字都同时拥有
    后者，反之亦然。诚然，我们能够证明这一点。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">gorgeous__beautiful_FAILED</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;0&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">b_0</span>.<br/>
&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="comment">(*&nbsp;我们在这里卡住了！&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
这里的问题在于进行基于<span class="inlinecode"><span class="id" type="var">n</span></span>的归纳并不能产出一个有用的归纳前提：知道某个性
    质是否被<span class="inlinecode"><span class="id" type="var">n</span></span>的前继所具有并不能帮助我们证明<span class="inlinecode"><span class="id" type="var">n</span></span>本身是否具有这个性质。但是作为
    替代地，我们希望能够得到有关其他数字的归纳前提，比如说<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">3</span>和<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">5</span>。这将由
    <span class="inlinecode"><span class="id" type="var">gorgeous</span></span>的构造子的形式精确地给出。
<div class="paragraph"> </div>

<a name="lab246"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 让我们看看当我们试图通过基于证据<span class="inlinecode"><span class="id" type="var">H</span></span>的归纳来进行这一证明时将会发生什么。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">gorgeous__beautiful</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n'</span>|<span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;g_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_0</span>.<br/>
&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;g_plus3&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_sum</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">b_3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHgorgeous</span>.<br/>
&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;g_plus5&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">b_sum</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">b_5</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHgorgeous</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="comment">(*&nbsp;这些练习也需要对证据使用归纳法。*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab247"></a><h4 class="section">Exercise: 2 stars (gorgeous_sum)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">gorgeous_sum</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> (<span class="id" type="var">n</span> + <span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab248"></a><h4 class="section">Exercise: 3 stars, advanced (beautiful__gorgeous)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beautiful__gorgeous</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">beautiful</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab249"></a><h4 class="section">Exercise: 3 stars, optional (g_times2)</h4>
 在不使用<span class="inlinecode"><span class="id" type="var">gorgeous__beautiful</span></span>的情况下证明<span class="inlinecode"><span class="id" type="var">g_times2</span></span>这一定理。
    你也许会发现下面的引理在证明过程中十分有用。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">helper_g_times2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <span class="id" type="var">x</span> + (<span class="id" type="var">z</span> + <span class="id" type="var">y</span>) = <span class="id" type="var">z</span> + <span class="id" type="var">x</span> + <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">g_times2</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">gorgeous</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">gorgeous</span> (2×<span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 下面是“具有归纳定义的偶数性是具有计算上的偶数性的充分条件”这一事实的证明。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ev__even</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">even</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHE'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab250"></a><h4 class="section">Exercise: 1 star (ev__even)</h4>
 这个证明能够通过对<span class="inlinecode"><span class="id" type="var">n</span></span>进行归纳完成吗？如果不能，为什么？
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 直观上，对证据<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>的归纳法与对<span class="inlinecode"><span class="id" type="var">n</span></span>的归纳法相似，但是它限制了我们的注意范
    围，让我们只关注可以让证据<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>被生成的数字。 
<div class="paragraph"> </div>

<a name="lab251"></a><h4 class="section">Exercise: 1 star (l_fails)</h4>
 以下的对证明的尝试不会成功。

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span>&nbsp;<span class="id" type="var">l</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>&nbsp;<span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span>&nbsp;<span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="comment">(*&nbsp;O&nbsp;*)</span>&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span>&nbsp;<span class="id" type="var">ev_0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="comment">(*&nbsp;S&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
<div class="paragraph"> </div>

</div>
   我们会直觉性地认为这个证明会无法被完成，因为并不是所有数字都是偶数。
   但是究竟是什么实际上导致了这一证明的失败？

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 下面是需要对证据进行归纳的又一个练习。<a name="lab252"></a><h4 class="section">Exercise: 2 stars (ev_sum)</h4>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ev_sum</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab253"></a><h2 class="section">对证据进行反演</h2>

<div class="paragraph"> </div>

 证明的时候持有某个命题的证据是十分有用的，因为我们可以通过对这些证据的
     <i>观察</i> 得到更多的信息。假设现在正在证明“若<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数则<span class="inlinecode"><span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>为偶数”
    这一命题，在这一情况下我们并不需要使用归纳法：<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>策略已经能够提供
    我们所需的全部信息。

<div class="paragraph"> </div>

 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ev_minus2</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,  <span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">pred</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">ev_0</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab254"></a><h4 class="section">Exercise: 1 star, optional (ev_minus2_n)</h4>
 假如我们试图以对<span class="inlinecode"><span class="id" type="var">n</span></span>使用<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>代替对<span class="inlinecode"><span class="id" type="var">E</span></span>的<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，那么会发生什么？ 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab255"></a><h3 class="section"> </h3>
 这里是另外一个展示了<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>能够缩小相关情况的范围的例子。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">SSev__even</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab256"></a><h2 class="section">再访反演策略</h2>

<div class="paragraph"> </div>

 刚开始的时候这些<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>的应用看上去可能会有一点奇怪。
    至今为止我们只是为了利用构造子的单射性或区分不同的构造子而在等价性命题上使用过
    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>而已。但是我们现在知道了<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>也可以被用于分析归纳定义的命
    题的证据。

<div class="paragraph"> </div>

    （你也许会认为<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>在这里会是个更加适合的策略。诚然，使用<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>
    是可能的，但是它常常会去掉有用的信息，而且在这里<span class="inlinecode"><span class="id" type="var">eqn</span>:</span>限定符并不能对挽救
    这一点起太大的作用。）  

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>的一般工作模式：假设<span class="inlinecode"><span class="id" type="var">I</span></span>是指向一个存在于当前上下文中的假设<span class="inlinecode"><span class="id" type="var">P</span></span>的标
    识符，那么对于<span class="inlinecode"><span class="id" type="var">P</span></span>的每一个构造子，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span>将会生成对应的子目标；而且在
    这些子目标中，<span class="inlinecode"><span class="id" type="var">I</span></span>被这个构造子的能够被用于证明<span class="inlinecode"><span class="id" type="var">P</span></span>时的特定情况代替。有些子目
    标是自我矛盾的，而<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>会去掉他们；剩下的子目标则是我们所必须证
    明以构建原初的目标的。

<div class="paragraph"> </div>

    在这个例子中，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>分析了<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>的构造，确定了它只能由
    <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>构造而来，并生成了一个包含了这个构造子的参数作为新的前提的子目标（它同时
    也生成了一个辅助等式，而在这个例子中它并没有用处。）

<div class="paragraph"> </div>

    我们会在接下来开始探索inversion的更一般的行为。 
<div class="paragraph"> </div>

<a name="lab257"></a><h4 class="section">Exercise: 1 star (inversion_practice)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">SSSSev__even</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)))) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>策略也可以被用于显示某个前提的荒谬来证明当前的目标。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">even5_nonsense</span> : <br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> 5 <span style="font-family: arial;">&rarr;</span> 2 + 2 = 9.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab258"></a><h4 class="section">Exercise: 3 stars, advanced (ev_ev__ev)</h4>
 在这个练习中找到适合进行归纳的对象可能有点困难： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ev_ev__ev</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab259"></a><h4 class="section">Exercise: 3 stars, optional (ev_plus_plus)</h4>
 这里是一个只需要应用已经存在的引理的练习。不需要任何的归纳法或分类讨论，
    只是有些重写步骤会稍显冗长。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ev_plus_plus</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ev</span> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">n</span>+<span class="id" type="var">p</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">m</span>+<span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab260"></a><h1 class="section">讨论和变形</h1>
<a name="lab261"></a><h2 class="section">计算性定义 vs. 归纳性定义</h2>

<div class="paragraph"> </div>

 我们已经能够看到“<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数”这一命题能够从两种方向解释——间接地通过一个
    布尔测试函数<span class="inlinecode"><span class="id" type="var">evenb</span></span>定义，或者直接归纳性地解释什么可以组成能够证实偶数性
    的证据。这两种不同的定义偶数性的方式同样地容易阐述，也同样地容易讨论。
    因此在这里，选择哪种方式仅仅是个人选择。

<div class="paragraph"> </div>

    然而对于许多其他的我们关心的性质而言一般推荐使用直接的归纳定义，因为有
    时编写一个测试函数会十分困难，或者甚至不可能。

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="var">beautiful</span></span>就是这样的一种性质。它作为一个数集的定义是完全可被理解的，
    但是我们无法将其转换成一个Coq Fixpoint（或者转换成任何常见的编程语言里的
    一个递归函数）。我们也许能够找到某种取巧的使用Fixpoint的检测这种性质的
    方法（诚然，就这个例子而言，得出这样的方法并不困难），然而就一般而言，
    这会需要十分深刻的思考。事实上，假如我们所关心的性质是不可计算的，那么
    无论我们如何努力，我们都无法用<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>定义它，因为Coq要求每一个
    <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>都要对应某个将会停机的运算。

<div class="paragraph"> </div>

    另一方面，就为了定义如何给出能够证实持有<span class="inlinecode"><span class="id" type="var">beautiful</span></span>这一性质的证据而言，
    直接写出一个归纳定义是十分直接的。 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab262"></a><h2 class="section">参数化数据结构</h2>

<div class="paragraph"> </div>

 至今为止我们只是接触过有关自然数的命题，但是我们能够定义有关任意类型的
    数据的归纳谓词。比如说，假如我们想要将“具有 <i>偶数</i> 长度的列表”特征化，我
    们能够通过下面的定义做到这一点： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">ev_list</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <span class="id" type="var">list</span> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">el_nil</span> : <span class="id" type="var">ev_list</span> []<br/>
&nbsp;&nbsp;| <span class="id" type="var">el_cc</span>  : <span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span>, <span class="id" type="var">ev_list</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev_list</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">y</span> :: <span class="id" type="var">l</span>).<br/>

<br/>
</div>

<div class="doc">
当然这个命题与声明列表的长度为偶数等价。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">ev_list__ev_length</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>), <span class="id" type="var">ev_list</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev</span> (<span class="id" type="var">length</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">l</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;el_nil&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">ev_0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;el_cc&nbsp;*)</span>  <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">ev_SS</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHev_list</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
然而由于<span class="inlinecode"><span class="id" type="var">ev</span></span>的证据包含的信息比<span class="inlinecode"><span class="id" type="var">ev_list</span></span>的证据所包含的更少，在证明另一个方
    向的时候必须十分小心。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">ev_length__ev_list</span>: <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">n</span>, <span class="id" type="var">ev</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>), <span class="id" type="var">n</span> = <span class="id" type="var">length</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ev_list</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">l</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;<span class="inlinecode"></span>&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">el_nil</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;x::l&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;ev_SS&nbsp;*)</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">l</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">x</span> [| <span class="id" type="var">x0</span> <span class="id" type="var">l</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;<span class="inlinecode"></span>&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" type="var">x</span></span>&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;x&nbsp;::&nbsp;x0&nbsp;::&nbsp;l&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">el_cc</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHev</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab263"></a><h4 class="section">Exercise: 4 stars (palindromes)</h4>
 回文指的是一种从反方向读的结果与从正方向读相同的序列。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 定义一个关于<span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>的能够说明什么是一段回文的归纳命题<span class="inlinecode"><span class="id" type="var">pal</span></span>。

<div class="paragraph"> </div>

      （提示：你会需要分三种情况。你的定义应该基于列表的结构。

<div class="paragraph"> </div>

        只用一个构造子：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">c</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>
<div class="paragraph"> </div>

</div>
        看上去或许能够明显地解决这个问题，但是这并不能很好地工作。）

<div class="paragraph"> </div>


</li>
<li> 证明<span class="inlinecode"><span class="id" type="var">pal_app_rev</span></span>：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;++&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>).
<div class="paragraph"> </div>

</div>

</li>
<li> 证明<span class="inlinecode"><span class="id" type="var">pal_rev</span></span>：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;由于缺乏证据，相反方向的证再一次地变得更加困难了。&nbsp;&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab264"></a><h4 class="section">Exercise: 5 stars, optional (palindrome_converse)</h4>
 使用在之前的练习中你给出的<span class="inlinecode"><span class="id" type="var">pal</span></span>的定义进行证明： 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab265"></a><h2 class="section">关系</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    一个附带了一个数字作为其参数的命题（比如<span class="inlinecode"><span class="id" type="var">ev</span></span>或者<span class="inlinecode"><span class="id" type="var">beautiful</span></span>）能够被看作是
    一种 <i>性质</i> ——它定义了一个<span class="inlinecode"><span class="id" type="var">nat</span></span>的子集，这个子集中包含了所有能够被证明拥有
    这一性质的数字。同样地，一个有两个参数的命题能够被看作是一种 <i>关系</i> ——
    它定义了一个包含所有能够被证明存在这一关系的序对的集合。 
</div>
<div class="code code-tight">

<br/>

<br/>
</div>

<div class="doc">
其中一个十分有用的例子是数字之间的“小于等于”的关系。 
<div class="paragraph"> </div>

 以下的定义应该足够符合直觉。它说明存在两种给出证实某个数字小于或等于另
    外一个数字的证据的方式：声明它们相等，或者声明其中一个数字小于或等于另
    外一个数字的前继。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">le</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">le_n</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">le</span> <span class="id" type="var">n</span> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">le_S</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, (<span class="id" type="var">le</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">le</span> <span class="id" type="var">n</span> (<span class="id" type="var">S</span> <span class="id" type="var">m</span>)).<br/>

<br/>
<span class="id" type="keyword">Notation</span> "m ≤ n" := (<span class="id" type="var">le</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

    使用构造子<span class="inlinecode"><span class="id" type="var">le_n</span></span>和<span class="inlinecode"><span class="id" type="var">le_S</span></span>证明关于<span class="inlinecode">≤</span>的事实的方法和证明与性质（比如说<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>一章
    中的<span class="inlinecode"><span class="id" type="var">ev</span></span>）相关的事实的方法相同。我们可以对构造子使用<span class="inlinecode"><span class="id" type="tactic">apply</span></span>以证明包含<span class="inlinecode">≤</span>的
    目标（举例而言，证明<span class="inlinecode">3≤3</span>或者<span class="inlinecode">3≤6</span>），也可以使用像<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>之类的证明策略
    来从存在于上下文中的包含<span class="inlinecode">≤</span>的前提提取出信息（如证明<span class="inlinecode">(2</span> <span class="inlinecode">≤</span> <span class="inlinecode">1)</span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>）。  
<div class="paragraph"> </div>

<a name="lab266"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

    这里有一些针对这个定义的正常性检查。（注意，即使这些与在之前的课程中为
    了测试我们写的函数而写的简单的“单元测试”是同一种事情，我们也必须构造出
    明晰的证明——<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>和<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>并不会完成这一工作，因为证明并不是只需
    通过简化就能完成的计算。） 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">test_le1</span> :<br/>
&nbsp;&nbsp;3 ≤ 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">le_n</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">test_le2</span> :<br/>
&nbsp;&nbsp;3 ≤ 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">le_S</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">le_S</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">le_S</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">test_le3</span> :<br/>
&nbsp;&nbsp;(2 ≤ 1) <span style="font-family: arial;">&rarr;</span> 2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab267"></a><h3 class="section"> </h3>
 现在“小于”关系（<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">m</span></span>）能够借助<span class="inlinecode"><span class="id" type="var">le</span></span>进行定义了。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>) := <span class="id" type="var">le</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) <span class="id" type="var">m</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "m &lt; n" := (<span class="id" type="var">lt</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
这里有一些简单的数字之间的关系： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">square_of</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">sq</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, <span class="id" type="var">square_of</span> <span class="id" type="var">n</span> (<span class="id" type="var">n</span> × <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">next_nat</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">nn</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, <span class="id" type="var">next_nat</span> <span class="id" type="var">n</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">next_even</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">ne_1</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">ev</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">next_even</span> <span class="id" type="var">n</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">ne_2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">next_even</span> <span class="id" type="var">n</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab268"></a><h4 class="section">Exercise: 2 stars (total_relation)</h4>
 定义一个每一对自然数之间都具有的归纳二元关系<span class="inlinecode"><span class="id" type="var">total_relation</span></span>。
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab269"></a><h4 class="section">Exercise: 2 stars (empty_relation)</h4>
 定义一个不可能被具有的关于数字的归纳二元关系<span class="inlinecode"><span class="id" type="var">empty_relation</span></span>。
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab270"></a><h4 class="section">Exercise: 2 stars, optional (le_exercises)</h4>
 这里有一些在后来的课程中所需要的关于<span class="inlinecode">≤</span>和<span class="inlinecode">&lt;</span>的事实。

<div class="paragraph"> </div>

    试着证明它们，这将会是很好的练习。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">le_trans</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <span class="id" type="var">m</span> ≤ <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> ≤ <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">m</span> ≤ <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">O_le_n</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;0 ≤ <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">n_le_m__Sn_le_Sm</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">S</span> <span class="id" type="var">n</span> ≤ <span class="id" type="var">S</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">Sn_le_Sm__n_le_m</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">S</span> <span class="id" type="var">n</span> ≤ <span class="id" type="var">S</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">le_plus_l</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">a</span> ≤ <span class="id" type="var">a</span> + <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_lt</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n1</span> + <span class="id" type="var">n2</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">n1</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">n2</span> &lt; <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">lt_S</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt; <span class="id" type="var">S</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ble_nat_true</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">le_ble_nat</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;提示：对<span class="inlinecode"><span class="id" type="var">m</span></span>使用归纳法可能是证明这一事实的最容易的方法。*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ble_nat_true_trans</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ble_nat</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;提示：这个定理的证明，不使用<span class="inlinecode"><span class="id" type="tactic">induction</span></span>就能轻易地完成。&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab271"></a><h4 class="section">Exercise: 2 stars, optional (ble_nat_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ble_nat_false</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span> ~(<span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab272"></a><h4 class="section">Exercise: 3 stars (R_provability2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Module</span> <span class="id" type="var">R</span>.<br/>
</div>

<div class="doc">
我们能够像定义二元关系一样定义三元关系或四元关系等等，例如下面的关于数
    字的三元关系： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">R</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c1</span> : <span class="id" type="var">R</span> 0 0 0 <br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <span class="id" type="var">R</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">R</span> (<span class="id" type="var">S</span> <span class="id" type="var">m</span>) <span class="id" type="var">n</span> (<span class="id" type="var">S</span> <span class="id" type="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c3</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <span class="id" type="var">R</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">R</span> <span class="id" type="var">m</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) (<span class="id" type="var">S</span> <span class="id" type="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c4</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <span class="id" type="var">R</span> (<span class="id" type="var">S</span> <span class="id" type="var">m</span>) (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">o</span>)) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">R</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c5</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <span class="id" type="var">R</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">R</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> 下面的命题中哪一个是可被证明的？
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1</span> <span class="inlinecode">2</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">2</span> <span class="inlinecode">6</span>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> 如果我们从<span class="inlinecode"><span class="id" type="var">R</span></span>的定义中去掉了构造子<span class="inlinecode"><span class="id" type="var">c5</span></span>，定义所描述的可证明的命题的集合
      改变了吗？用一句话给出你的答案。

<div class="paragraph"> </div>


</li>
<li> 如果我们去掉构造子<span class="inlinecode"><span class="id" type="var">c4</span></span>，定义所描述的可证明的命题的集合改变了吗？
      用一句话给出你的答案。

</li>
</ul>

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab273"></a><h4 class="section">Exercise: 3 stars, optional (R_fact)</h4>
 实际上关系<span class="inlinecode"><span class="id" type="var">R</span></span>定义了一个熟悉的函数。声明并证明这两个连接这一关系和所定义
    的函数的定理。也即是说，如果<span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">o</span></span>为真，那么我们能够声称<span class="inlinecode"><span class="id" type="var">m</span></span>，<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">o</span></span>
    之间存在着什么样的关系？以及如果<span class="inlinecode"><span class="id" type="var">m</span></span>，<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">o</span></span>存在这一关系，那么我们是否
    能够证明<span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">o</span></span>？

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">R</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab274"></a><h4 class="section">Exercise: 4 stars, advanced (subsequence)</h4>
 如果一个列表中的所有元素在另一个列表中按照相同的顺序（其中可能插有其他
    元素）出现，那么这个列表是另一个列表的 <i>子序列</i> 。例如：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]
<div class="paragraph"> </div>

</div>
    是以下列表的子序列：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1;1;1;2;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1;2;7;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[5;6;1;9;9;2;7;3;8]
<div class="paragraph"> </div>

</div>
    而 <i>不是</i> 以下任何一个列表的子序列：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[5;6;2;1;7;3;8]
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<ul class="doclist">
<li> 定义一个关于<span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>的能够准确描述什么是子序列的归纳命题<span class="inlinecode"><span class="id" type="var">subseq</span></span>。
      （提示：你需要分三种不同的情况。）

</li>
<li> 证明<span class="inlinecode"><span class="id" type="var">subseq_refl</span></span>：子序列这一关系具有自反性，即证明任意一个列表都是
      自身的子序列。

</li>
<li> 证明<span class="inlinecode"><span class="id" type="var">subseq_app</span></span>：对于任意列表<span class="inlinecode"><span class="id" type="var">l1</span></span>，<span class="inlinecode"><span class="id" type="var">l2</span></span>和<span class="inlinecode"><span class="id" type="var">l3</span></span>，如果<span class="inlinecode"><span class="id" type="var">l1</span></span>是<span class="inlinecode"><span class="id" type="var">l2</span></span>的一个子序列，
      那么<span class="inlinecode"><span class="id" type="var">l1</span></span>是<span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span>的一个子序列。

</li>
<li> （可选的，比较困难）证明<span class="inlinecode"><span class="id" type="var">subseq_trans</span></span>：子序列这一关系具有传递性，
      即当<span class="inlinecode"><span class="id" type="var">l1</span></span>是<span class="inlinecode"><span class="id" type="var">l2</span></span>的一个子序列且<span class="inlinecode"><span class="id" type="var">l2</span></span>是<span class="inlinecode"><span class="id" type="var">l3</span></span>的一个子序列时，<span class="inlinecode"><span class="id" type="var">l1</span></span>也是<span class="inlinecode"><span class="id" type="var">l3</span></span>的一
      个子序
      列。提示：小心地选择你进行归纳的对象！

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab275"></a><h4 class="section">Exercise: 2 stars, optional (R_provability)</h4>
 假设我们向Coq给出下面的定义：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">R</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c1</span>&nbsp;:&nbsp;<span class="id" type="var">R</span>&nbsp;0&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c2</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c3</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>
    那么下述命题中哪些是可证实的？

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;2;1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">6</span> <span class="inlinecode">[3;2;1;0]</span>

</li>
</ul>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab276"></a><h1 class="section">使用命题进行编程</h1>

<div class="paragraph"> </div>

 与我们已经看到的一样， <i>命题</i> ，例如“二加二等于四”，是一种表达了对某个事
          实的某种宣称的语句。在Coq中，命题用类型为<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的表达式表示。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (2 + 2 = 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">ble_nat</span> 3 2 = <span class="id" type="var">false</span>).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ble_nat&nbsp;3&nbsp;2&nbsp;=&nbsp;false&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">beautiful</span> 8).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;beautiful&nbsp;8&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab277"></a><h3 class="section"> </h3>
 可证的宣称与不可证的宣称都是完全合法的命题； <i>是不是</i> 一个命题是一回事，
    而 <i>是否可证</i> 则又是另外一回事了。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (2 + 2 = 5).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;5&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">beautiful</span> 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;beautiful&nbsp;4&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">4</span>与<span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>都是合法的类型为<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的表达式。 
<div class="paragraph"> </div>

<a name="lab278"></a><h3 class="section"> </h3>
 至今为止我们主要在Coq中命题能够出现的其中一种地方看到它们：在
    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>（以及<span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>和<span class="inlinecode"><span class="id" type="keyword">Example</span></span>）定义中。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_2_2_is_4</span> : <br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
但是它们也有许多其他的使用方式。比如说，我们已经知道我们可以像给其他类
    型的表达式赋予名字一样用<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>来给某个命题赋予一个名字。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">plus_fact</span> : <span class="id" type="keyword">Prop</span>  :=  2 + 2 = 4.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">plus_fact</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;plus_fact&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
在这之后我们能够在任何需要一个命题的地方使用这个名字，例如在一个<span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>定义中： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_fact_is_true</span> : <br/>
&nbsp;&nbsp;<span class="id" type="var">plus_fact</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab279"></a><h3 class="section"> </h3>
 我们已经知道构造命题的几种不同的方式：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 我们能够通过<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>定义一个新的命题

<div class="paragraph"> </div>


</li>
<li> 给定两个相同类型的表达式<span class="inlinecode"><span class="id" type="var">e1</span></span>和<span class="inlinecode"><span class="id" type="var">e2</span></span>，我们能够构造命题<span class="inlinecode"><span class="id" type="var">e1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e2</span></span>；这宣称它
         们的值相等。

<div class="paragraph"> </div>


</li>
<li> 我们能够通过蕴含和量化来组合命题。 
</li>
</ul>
<a name="lab280"></a><h3 class="section"> </h3>
 我们也已经看到类似于<span class="inlinecode"><span class="id" type="var">even</span></span>和<span class="inlinecode"><span class="id" type="var">beautiful</span></span>的 <i>参数化命题</i> 。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">even</span> 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;4&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">even</span> 3).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;3&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">even</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab281"></a><h3 class="section"> </h3>
 <span class="inlinecode"><span class="id" type="var">even</span></span>的类型，也即是<span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，可以从三种等价的角度解读：

<div class="paragraph"> </div>

              (1) “<span class="inlinecode"><span class="id" type="var">even</span></span>是一个从数字映射到命题的 <i>函数</i> 。”

<div class="paragraph"> </div>

              (2) “<span class="inlinecode"><span class="id" type="var">even</span></span>是一个与自然数<span class="inlinecode"><span class="id" type="var">n</span></span>一一对应的命题的集合。”

<div class="paragraph"> </div>

              (3) “<span class="inlinecode"><span class="id" type="var">even</span></span>是一个有关数字的 <i>性质</i> 。”  
<div class="paragraph"> </div>

 在Coq中，命题——包括参数化的命题——是一等公民。举例而言，我们能够定
    义从数字映射至命题的函数…… 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">between</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>: <span class="id" type="var">nat</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">andb</span> (<span class="id" type="var">ble_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>) (<span class="id" type="var">ble_nat</span> <span class="id" type="var">o</span> <span class="id" type="var">m</span>) = <span class="id" type="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
……然后将它们部分应用： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">teen</span> : <span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span> := <span class="id" type="var">between</span> 13 19.<br/>

<br/>
</div>

<div class="doc">
我们甚至能够传递命题——包括参数化的命题——作为函数的参数： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">true_for_zero</span> (<span class="id" type="var">P</span>:<span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> 0.<br/>

<br/>
</div>

<div class="doc">
<a name="lab282"></a><h3 class="section"> </h3>
 这里有两个以参数化命题作为参数传递给函数的例子。

<div class="paragraph"> </div>

    第一个函数<span class="inlinecode"><span class="id" type="var">true_for_all_numbers</span></span>取一个命题<span class="inlinecode"><span class="id" type="var">P</span></span>作为其参数，然后构建宣称<span class="inlinecode"><span class="id" type="var">P</span></span>对于
    所有自然数都成立的命题。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">true_for_all_numbers</span> (<span class="id" type="var">P</span>:<span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">P</span> <span class="id" type="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
第二个函数<span class="inlinecode"><span class="id" type="var">preserved_by_S</span></span>会在取命题<span class="inlinecode"><span class="id" type="var">P</span></span>作为参数后构建这样一种命题：它宣称
    如果<span class="inlinecode"><span class="id" type="var">P</span></span>对于某个自然数<span class="inlinecode"><span class="id" type="var">n'</span></span>为真，那么它对于<span class="inlinecode"><span class="id" type="var">n'</span></span>的后继也为真——也即是说<span class="inlinecode"><span class="id" type="var">P</span></span> <i>通过
    后继被保持</i> ： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">preserved_by_S</span> (<span class="id" type="var">P</span>:<span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n'</span>, <span class="id" type="var">P</span> <span class="id" type="var">n'</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab283"></a><h3 class="section"> </h3>
 最后，我们可以将这些成分组合起来定义自然数的归纳规则： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">natural_number_induction_valid</span> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true_for_zero</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">preserved_by_S</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true_for_all_numbers</span> <span class="id" type="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab284"></a><h4 class="section">Exercise: 3 stars (combine_odd_even)</h4>
 完成下面函数<span class="inlinecode"><span class="id" type="var">combine_odd_even</span></span>的定义。它取两个有关数字的性质<span class="inlinecode"><span class="id" type="var">Podd</span></span>和<span class="inlinecode"><span class="id" type="var">Peven</span></span>，
    而它应该返回一个在<span class="inlinecode"><span class="id" type="var">n</span></span>为奇数时等价于<span class="inlinecode"><span class="id" type="var">Peven</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>，在<span class="inlinecode"><span class="id" type="var">n</span></span>为偶数时等价于<span class="inlinecode"><span class="id" type="var">Podd</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
的命题<span class="inlinecode"><span class="id" type="var">P</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">combine_odd_even</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
看看你是否能够证明下述的事实以测试你的定义： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_intro</span> : <br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Podd</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_odd</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Podd</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_even</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
这里有一个给热衷冒险的人准备的额外挑战：如果我们可以使用<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>定义
    参数化命题，那么我们是否可以用<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>定义它们？当然可以！然而这种“递
    归参数化”并不与我们非常熟悉的日常的数学的任何一部分相对应。下面的练习
    给出了一个稍微有些不自然的例子。 
<div class="paragraph"> </div>

<a name="lab285"></a><h4 class="section">Exercise: 4 stars, optional (true_upto_n__true_everywhere)</h4>
 Define a recursive function
    <span class="inlinecode"><span class="id" type="var">true_upto_n__true_everywhere</span></span> that makes
    <span class="inlinecode"><span class="id" type="var">true_upto_n_example</span></span> work. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;<br/>
Fixpoint&nbsp;true_upto_n__true_everywhere<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<br/>
Example&nbsp;true_upto_n_example&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(true_upto_n__true_everywhere&nbsp;3&nbsp;(fun&nbsp;n&nbsp;=&gt;&nbsp;even&nbsp;n))<br/>
&nbsp;&nbsp;=&nbsp;(even&nbsp;3&nbsp;-&gt;&nbsp;even&nbsp;2&nbsp;-&gt;&nbsp;even&nbsp;1&nbsp;-&gt;&nbsp;forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;even&nbsp;m).<br/>
Proof.&nbsp;reflexivity.&nbsp;&nbsp;Qed.<br/>
*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

  
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>
