<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Basics</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Basics</h1>

<div class="code code-tight">
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">基础知识: Coq中的函数式编程</h1>

</div>
<div class="code code-space">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">Admitted</span></span>是Coq的"紧急出口"，就是说接受一个定义而暂不证明。我们用它<br/>
&nbsp;&nbsp;&nbsp;来代表学习过程中的'空白'，这些空白应该由你的作业练习来补上。在实际<br/>
&nbsp;&nbsp;&nbsp;运用中，当你一步步地完成一个大型证明时<span class="inlinecode"><span class="id" type="var">Admitted</span></span>也非常有用。&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">admit</span> {<span class="id" type="var">T</span>: <span class="id" type="keyword">Type</span>} : <span class="id" type="var">T</span>. <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h1 class="section">简介</h1>

<div class="paragraph"> </div>

 函数式编程风格使得编程更接近简单的、日常的数学：当一个过程或方法
    没有副作用，那么所有你需要去理解的也就是如何将输入对应到输出而已 ——
    或者说，你可以把它当做是一个用来计算数学函数的具体方法。这也就是
    "函数式编程"中"函数式"一词的含义之一。程序与简单数学对象之间的关联
    同时支撑了有关程序行为正确性的形式化证明以及非形式化合理论证。

<div class="paragraph"> </div>

    函数式编程中'函数式'一词的另一个含义是它强调把函数(或方法)作为
    <i>第一等_ 的值 —— 换言之，这个值可以作为参数传递给其他函数，可以作为
    结果返回，也可以存储在数据结构中，等等。这种把函数当做数据的认可
    形式使得很多既有用且强大的用法成为可能。

<div class="paragraph"> </div>

    其他一些常见的函数式语言的特性包括 <i>代数数据类型_ 和 <i>模式匹配_
    (使得构造和处理更丰富的数据结构更简单)，以及复杂的 <i>多态类型系统_
    (用来支持抽象和代码复用)。Coq提供所有这些特性。

<div class="paragraph"> </div>

    这一章的前半部分介绍了Coq函数式编程语言的最基本的元素，后半部分
    介绍了可被用于证明Coq程序一些简单特点的基本 <i>策略_ 。

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h1 class="section">可枚举类型</h1>

<div class="paragraph"> </div>

 Coq一个不寻常的地方就是它内置的特性集合 <i>极其_ 之小。比如，Coq不提供
    通常的原子数据类型(如布尔值、整数、字符串等等)，而是提供一种极其强大的
    可从头定义新数据类型的机制 —— 强大到以上这些常见的类型都是它定义产生出的
    实例。
    当然，Coq发行版也同时提供了一个内容丰富的标准库，包含了布尔值、数值，
    以及如列表、杂凑表等很多常用的数据结构。但是这些库中的定义并没有
    任何地方特殊或者是语言里原生的：它们都是普普通通的用户代码。为了说明
    这个，我们在整个教程里显式的重新定义了所有我们所需要的数据类型，
    而不是隐式的使用库里那些。
    来看看这个机制是如何工作的，让我们从一个非常简单的例子开始。
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h2 class="section">一周里的日子</h2>

<div class="paragraph"> </div>

 下面的声明形式告诉Coq我们在定义一个新的数值集合 —— 一个 <i>类型_ 。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">day</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span> : <span class="id" type="var">day</span>.<br/>

<br/>
</div>

<div class="doc">
这个类型叫做<span class="inlinecode"><span class="id" type="var">day</span></span>, 它的成员包括<span class="inlinecode"><span class="id" type="var">monday</span></span>、<span class="inlinecode"><span class="id" type="var">tuesday</span></span>等等。定义从第二行起，
    包括后面的行，可以被读作"<span class="inlinecode"><span class="id" type="var">monday</span></span>是一个<span class="inlinecode"><span class="id" type="var">day</span></span>"，"<span class="inlinecode"><span class="id" type="var">tuesday</span></span>是一个<span class="inlinecode"><span class="id" type="var">day</span></span>"，以此类推。
    在定义了<span class="inlinecode"><span class="id" type="var">day</span></span>类型以后, 我们就可以来写一些函数操作day了. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">next_weekday</span> (<span class="id" type="var">d</span>:<span class="id" type="var">day</span>) : <span class="id" type="var">day</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span>    ⇒ <span class="id" type="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span>   ⇒ <span class="id" type="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span> ⇒ <span class="id" type="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span>  ⇒ <span class="id" type="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span>    ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span>  ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span>    ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
注意，这里函数的参数以及返回值是被显式声明的。其实像大多数函数式
    编程语言一样，如果没有显式给出，Coq自己通常也可以得出这些类型
    —— 也就是说，它会做一些 <i>类型推断_ —— 但这里我们都会声明它们，
    这样可使得阅读起来方便些。
<div class="paragraph"> </div>

 在定义完函数后，我们用一些例子来检验它。实际上，在Coq中可以用三种
    不同方式来做这件事。

<div class="paragraph"> </div>

    第一，我们可以用命令<span class="inlinecode"><span class="id" type="var">Compute</span></span>来计算一个包含<span class="inlinecode"><span class="id" type="var">next_weekday</span></span>的合成表达式。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Compute</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">friday</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;monday&nbsp;:&nbsp;day&nbsp;*)</span><br/>
<span class="id" type="var">Compute</span> (<span class="id" type="var">next_weekday</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">saturday</span>)).<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;tuesday&nbsp;:&nbsp;day&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
如果你手边就有电脑，那现在是一个好机会来打开Coq解释器并选用一个你
    喜欢的IDE —— CoqIde 或是 Proof General 都可以 —— 然后自己试一试。
    从这本书附带的Coq源码中载入<span class="inlinecode"><span class="id" type="var">Basics.v</span></span>文件，找到上述例子，提交到Coq，
    然后查看结果。
<div class="paragraph"> </div>

 第二，我们可以用Coq例子的形式来记录我们所期望的结果是什么： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_next_weekday</span>:<br/>
&nbsp;&nbsp;(<span class="id" type="var">next_weekday</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">saturday</span>)) = <span class="id" type="var">tuesday</span>.<br/>

<br/>
</div>

<div class="doc">
这个声明形式做了两件事：一是它做了一个断言(即：<span class="inlinecode"><span class="id" type="var">saturday</span></span>之后的
    第二个工作日是<span class="inlinecode"><span class="id" type="var">tuesday</span></span>)；二是它给这个断言起了个名字，以便于以后
    用此名字来引用此断言。 定义好断言后，我们还能要求Coq来验证它，像这样：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
在这里一些细节不重要(后面我们还会回顾它)，重要的是这可以是说
    "进行一些化简后，通过观察等式两边计算得到相同的东西，我们刚刚给出的
    断言就可以被验证了。"  第三，我们可以让Coq从我们的<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>中 <i>提炼出_ 一个其他编程
    语言(诸如OCaml、Scheme、Haskell等)的程序，这些语言有着高性能的
    编译器。这个能力非常有用，因为它能够提供给我们一种使用主流编程语言来
    构造 <i>经过充分验证的_ 程序的方式。实际上，这也是Coq被开发出来以后
    最主要的一种使用方式。后面的章节我们会再回来说这个内容。更多内容
    可以在Bertot和Casteran编写的Coq's Art一书中找到，或者是Coq参考手册。
</div>
<div class="code code-tight">
</div>

<div class="doc">
<a name="lab20"></a><h2 class="section">布尔值</h2>
 用类似的方式，我们可以定义标准类型<span class="inlinecode"><span class="id" type="var">bool</span></span>表示布尔值，它包含
    <span class="inlinecode"><span class="id" type="var">true</span></span>和<span class="inlinecode"><span class="id" type="var">false</span></span>两个成员。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">bool</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> : <span class="id" type="var">bool</span>.<br/>
</div>

<div class="doc">
尽管我们为了所谓"一切从头来"而在这里搞出我们自己的布尔类型，实际上，
    Coq在其标准库中也提供了布尔类型的缺省实现，同时提供大量有用的函数和
    定理。(有兴趣的话可参见Coq库文档中的<span class="inlinecode"><span class="id" type="var">Coq.Init.Datatypes</span></span>。)尽可能地，
    我们会将我们自己的定义和定理的命名做成与标准库中的命名完全一致。 布尔值上的函数可用与上文相同的方式来定义：
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">negb</span> (<span class="id" type="var">b</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">b2</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">orb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">b2</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
后面两个演示了具有多个参数的函数的定义语法。 下面四个"单元测试"构成了针对<span class="inlinecode"><span class="id" type="var">orb</span></span>函数的完整规范 —— 真值表：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb1</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span>  <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb2</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb3</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb4</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span>  <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<i>A note on notation</i>: In .v files, we use square brackets to
    delimit fragments of Coq code within comments; this convention,
    also used by the <span class="inlinecode"><span class="id" type="var">coqdoc</span></span> documentation tool, keeps them visually
    separate from the surrounding text.  In the html version of the
    files, these pieces of text appear in a <span class="inlinecode"><span class="id" type="var">different</span></span> <span class="inlinecode"><span class="id" type="var">font</span></span>. 
<div class="paragraph"> </div>

 The values <span class="inlinecode"><span class="id" type="var">Admitted</span></span> and <span class="inlinecode"><span class="id" type="var">admit</span></span> can be used to fill
    a hole in an incomplete definition or proof.  We'll use them in the
    following exercises.  In general, your job in the exercises is 
    to replace <span class="inlinecode"><span class="id" type="var">admit</span></span> or <span class="inlinecode"><span class="id" type="var">Admitted</span></span> with real definitions or proofs. 
<div class="paragraph"> </div>

<a name="lab21"></a><h4 class="section">Exercise: 1 star (nandb)</h4>
 Complete the definition of the following function, then make
    sure that the <span class="inlinecode"><span class="id" type="keyword">Example</span></span> assertions below can each be verified by
    Coq.  
<div class="paragraph"> </div>

 This function should return <span class="inlinecode"><span class="id" type="var">true</span></span> if either or both of
    its inputs are <span class="inlinecode"><span class="id" type="var">false</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">nandb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
Remove "<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>" and fill in each proof with 
    "<span class="inlinecode"><span class="id" type="keyword">Proof</span>.</span> <span class="inlinecode"><span class="id" type="tactic">simpl</span>.</span> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span>.</span> <span class="inlinecode"><span class="id" type="keyword">Qed</span>.</span>" 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb1</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb2</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb3</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb4</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab22"></a><h4 class="section">Exercise: 1 star (andb3)</h4>
 Do the same for the <span class="inlinecode"><span class="id" type="var">andb3</span></span> function below. This function should
    return <span class="inlinecode"><span class="id" type="var">true</span></span> when all of its inputs are <span class="inlinecode"><span class="id" type="var">true</span></span>, and <span class="inlinecode"><span class="id" type="var">false</span></span>
    otherwise. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb3</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b3</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb31</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb32</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb33</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb34</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h2 class="section">Function Types</h2>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="keyword">Check</span></span> command causes Coq to print the type of an
    expression.  For example, the type of <span class="inlinecode"><span class="id" type="var">negb</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> is <span class="inlinecode"><span class="id" type="var">bool</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">negb</span> <span class="id" type="var">true</span>).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;negb&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Functions like <span class="inlinecode"><span class="id" type="var">negb</span></span> itself are also data values, just like
    <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span>.  Their types are called <i>function types</i>, and
    they are written with arrows. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">negb</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;negb&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The type of <span class="inlinecode"><span class="id" type="var">negb</span></span>, written <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> and pronounced
    "<span class="inlinecode"><span class="id" type="var">bool</span></span> arrow <span class="inlinecode"><span class="id" type="var">bool</span></span>," can be read, "Given an input of type
    <span class="inlinecode"><span class="id" type="var">bool</span></span>, this function produces an output of type <span class="inlinecode"><span class="id" type="var">bool</span></span>."
    Similarly, the type of <span class="inlinecode"><span class="id" type="var">andb</span></span>, written <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span>, can
    be read, "Given two inputs, both of type <span class="inlinecode"><span class="id" type="var">bool</span></span>, this function
    produces an output of type <span class="inlinecode"><span class="id" type="var">bool</span></span>." 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab24"></a><h2 class="section">Numbers</h2>

<div class="paragraph"> </div>

 <i>Technical digression</i>: Coq provides a fairly sophisticated
    <i>module system</i>, to aid in organizing large developments.  In this
    course we won't need most of its features, but one is useful: If
    we enclose a collection of declarations between <span class="inlinecode"><span class="id" type="keyword">Module</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> and
    <span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> markers, then, in the remainder of the file after the
    <span class="inlinecode"><span class="id" type="keyword">End</span></span>, these definitions will be referred to by names like <span class="inlinecode"><span class="id" type="var">X.foo</span></span>
    instead of just <span class="inlinecode"><span class="id" type="var">foo</span></span>.  Here, we use this feature to introduce the
    definition of the type <span class="inlinecode"><span class="id" type="var">nat</span></span> in an inner module so that it does
    not shadow the one from the standard library. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Playground1</span>.<br/>

<br/>
</div>

<div class="doc">
The types we have defined so far are examples of "enumerated
    types": their definitions explicitly enumerate a finite set of
    elements.  A more interesting way of defining a type is to give a
    collection of "inductive rules" describing its elements.  For
    example, we can define the natural numbers as follows: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">nat</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
The clauses of this definition can be read: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">O</span></span> is a natural number (note that this is the letter "<span class="inlinecode"><span class="id" type="var">O</span></span>," not
        the numeral "<span class="inlinecode">0</span>").

</li>
<li> <span class="inlinecode"><span class="id" type="var">S</span></span> is a "constructor" that takes a natural number and yields
        another one &mdash; that is, if <span class="inlinecode"><span class="id" type="var">n</span></span> is a natural number, then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
        is too.

</li>
</ul>

<div class="paragraph"> </div>

    Let's look at this in a little more detail.  

<div class="paragraph"> </div>

    Every inductively defined set (<span class="inlinecode"><span class="id" type="var">day</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">bool</span></span>, etc.) is
    actually a set of <i>expressions</i>.  The definition of <span class="inlinecode"><span class="id" type="var">nat</span></span> says how
    expressions in the set <span class="inlinecode"><span class="id" type="var">nat</span></span> can be constructed:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the expression <span class="inlinecode"><span class="id" type="var">O</span></span> belongs to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>; 

</li>
<li> if <span class="inlinecode"><span class="id" type="var">n</span></span> is an expression belonging to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>, then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
      is also an expression belonging to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>; and

</li>
<li> expressions formed in these two ways are the only ones belonging
      to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>.

</li>
</ul>
    The same rules apply for our definitions of <span class="inlinecode"><span class="id" type="var">day</span></span> and <span class="inlinecode"><span class="id" type="var">bool</span></span>. The
    annotations we used for their constructors are analogous to the
    one for the <span class="inlinecode"><span class="id" type="var">O</span></span> constructor, and indicate that each of those
    constructors doesn't take any arguments. 
<div class="paragraph"> </div>

 These three conditions are the precise force of the
    <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> declaration.  They imply that the expression <span class="inlinecode"><span class="id" type="var">O</span></span>, the
    expression <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>, the expression <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span>, the expression
    <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>, and so on all belong to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>, while other
    expressions like <span class="inlinecode"><span class="id" type="var">true</span></span>, <span class="inlinecode"><span class="id" type="var">andb</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span>, and <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">false</span>)</span> do
    not.

<div class="paragraph"> </div>

    We can write simple functions that pattern match on natural
    numbers just as we did above &mdash; for example, the predecessor
    function: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">pred</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The second branch can be read: "if <span class="inlinecode"><span class="id" type="var">n</span></span> has the form <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>
    for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, then return <span class="inlinecode"><span class="id" type="var">n'</span></span>."  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Playground1</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">minustwo</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) ⇒ <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Because natural numbers are such a pervasive form of data,
    Coq provides a tiny bit of built-in magic for parsing and printing
    them: ordinary arabic numerals can be used as an alternative to
    the "unary" notation defined by the constructors <span class="inlinecode"><span class="id" type="var">S</span></span> and <span class="inlinecode"><span class="id" type="var">O</span></span>.  Coq
    prints numbers in arabic form by default: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)))).<br/>
<span class="id" type="var">Compute</span> (<span class="id" type="var">minustwo</span> 4).<br/>

<br/>
</div>

<div class="doc">
The constructor <span class="inlinecode"><span class="id" type="var">S</span></span> has the type <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, just like the
    functions <span class="inlinecode"><span class="id" type="var">minustwo</span></span> and <span class="inlinecode"><span class="id" type="var">pred</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">S</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">pred</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">minustwo</span>.<br/>

<br/>
</div>

<div class="doc">
These are all things that can be applied to a number to yield a
    number.  However, there is a fundamental difference: functions
    like <span class="inlinecode"><span class="id" type="var">pred</span></span> and <span class="inlinecode"><span class="id" type="var">minustwo</span></span> come with <i>computation rules</i> &mdash; e.g.,
    the definition of <span class="inlinecode"><span class="id" type="var">pred</span></span> says that <span class="inlinecode"><span class="id" type="var">pred</span></span> <span class="inlinecode">2</span> can be simplified to
    <span class="inlinecode">1</span> &mdash; while the definition of <span class="inlinecode"><span class="id" type="var">S</span></span> has no such behavior attached.
    Although it is like a function in the sense that it can be applied
    to an argument, it does not <i>do</i> anything at all! 
<div class="paragraph"> </div>

 For most function definitions over numbers, pure pattern
    matching is not enough: we also need recursion.  For example, to
    check that a number <span class="inlinecode"><span class="id" type="var">n</span></span> is even, we may need to recursively check
    whether <span class="inlinecode"><span class="id" type="var">n</span>-2</span> is even.  To write such functions, we use the
    keyword <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">evenb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>        ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">O</span>      ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) ⇒ <span class="id" type="var">evenb</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can define <span class="inlinecode"><span class="id" type="var">oddb</span></span> by a similar <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> declaration, but here
    is a simpler definition that will be a bit easier to work with: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">oddb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span>   :=   <span class="id" type="var">negb</span> (<span class="id" type="var">evenb</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb1</span>:    (<span class="id" type="var">oddb</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb2</span>:    (<span class="id" type="var">oddb</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))))) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Naturally, we can also define multi-argument functions by
    recursion.  (Once again, we use a module to avoid polluting the
    namespace.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Playground2</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">plus</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">S</span> (<span class="id" type="var">plus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Adding three to two now gives us five, as we'd expect. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Compute</span> (<span class="id" type="var">plus</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))).<br/>

<br/>
</div>

<div class="doc">
The simplification that Coq performs to reach this conclusion can
    be visualized as follows: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>&nbsp;&nbsp;&nbsp;&nbsp;<br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))))</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;the&nbsp;first&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
As a notational convenience, if two or more arguments have
    the same type, they can be written together.  In the following
    definition, <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> means just the same as if we had written
    <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">mult</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">plus</span> <span class="id" type="var">m</span> (<span class="id" type="var">mult</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_mult1</span>: (<span class="id" type="var">mult</span> 3 3) = 9.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You can match two expressions at once by putting a comma
    between them: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">minus</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span>, <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>   , <span class="id" type="var">_</span>    ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">_</span> , <span class="id" type="var">O</span>    ⇒ <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span>, <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">minus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The _ in the first line is a <i>wildcard pattern</i>.  Writing _ in a
    pattern is the same as writing some variable that doesn't get used
    on the right-hand side.  This avoids the need to invent a bogus
    variable name. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Playground2</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">exp</span> (<span class="id" type="var">base</span> <span class="id" type="var">power</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">power</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">S</span> <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">p</span> ⇒ <span class="id" type="var">mult</span> <span class="id" type="var">base</span> (<span class="id" type="var">exp</span> <span class="id" type="var">base</span> <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab25"></a><h4 class="section">Exercise: 1 star (factorial)</h4>
 Recall the standard factorial function:
<pre>
    factorial(0)  =  1 
    factorial(n)  =  n * factorial(n-1)     (if n&gt;0)
</pre>
    Translate this into Coq. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">factorial</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> := <br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial1</span>:          (<span class="id" type="var">factorial</span> 3) = 6.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial2</span>:          (<span class="id" type="var">factorial</span> 5) = (<span class="id" type="var">mult</span> 10 12).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 We can make numerical expressions a little easier to read and
    write by introducing "notations" for addition, multiplication, and
    subtraction. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x + y" := (<span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x - y" := (<span class="id" type="var">minus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x × y" := (<span class="id" type="var">mult</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 40, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> ((0 + 1) + 1).<br/>

<br/>
</div>

<div class="doc">
(The <span class="inlinecode"><span class="id" type="var">level</span></span>, <span class="inlinecode"><span class="id" type="var">associativity</span></span>, and <span class="inlinecode"><span class="id" type="var">nat_scope</span></span> annotations
   control how these notations are treated by Coq's parser.  The
   details are not important, but interested readers can refer to the
   "More on Notation" subsection in the "Advanced Material" section at
   the end of this chapter.) 
<div class="paragraph"> </div>

 Note that these do not change the definitions we've already
    made: they are simply instructions to the Coq parser to accept <span class="inlinecode"><span class="id" type="var">x</span></span>
    <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">y</span></span> in place of <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> and, conversely, to the Coq
    pretty-printer to display <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> as <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">y</span></span>. 
<div class="paragraph"> </div>

 When we say that Coq comes with nothing built-in, we really
    mean it: even equality testing for numbers is a user-defined
    operation!  The <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" type="var">eq</span></span>uality,
    yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean.  Note the use of nested <span class="inlinecode"><span class="id" type="keyword">match</span></span>es (we could
    also have used a simultaneous match, as we did in <span class="inlinecode"><span class="id" type="var">minus</span></span>.)  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">beq_nat</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, the <span class="inlinecode"><span class="id" type="var">ble_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for
    <span class="inlinecode"><span class="id" type="var">l</span></span>ess-or-<span class="inlinecode"><span class="id" type="var">e</span></span>qual, yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ble_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">ble_nat</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat1</span>:             (<span class="id" type="var">ble_nat</span> 2 2) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat2</span>:             (<span class="id" type="var">ble_nat</span> 2 4) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat3</span>:             (<span class="id" type="var">ble_nat</span> 4 2) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h4 class="section">Exercise: 2 stars (blt_nat)</h4>
 The <span class="inlinecode"><span class="id" type="var">blt_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" type="var">l</span></span>ess-<span class="inlinecode"><span class="id" type="var">t</span></span>han,
    yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean.  Instead of making up a new <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> for
    this one, define it in terms of a previously defined function. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">blt_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat1</span>:             (<span class="id" type="var">blt_nat</span> 2 2) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat2</span>:             (<span class="id" type="var">blt_nat</span> 2 4) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat3</span>:             (<span class="id" type="var">blt_nat</span> 4 2) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h1 class="section">Proof by Simplification</h1>

<div class="paragraph"> </div>

 Now that we've defined a few datatypes and functions, let's
    turn to the question of how to state and prove properties of their
    behavior.  Actually, in a sense, we've already started doing this:
    each <span class="inlinecode"><span class="id" type="keyword">Example</span></span> in the previous sections makes a precise claim
    about the behavior of some function on some particular inputs.
    The proofs of these claims were always the same: use <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> to
    simplify both sides of the equation, then use <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> to
    check that both sides contain identical values.

<div class="paragraph"> </div>

    The same sort of "proof by simplification" can be used to prove
    more interesting properties as well.  For example, the fact that
    <span class="inlinecode">0</span> is a "neutral element" for <span class="inlinecode">+</span> on the left can be proved just
    by observing that <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> reduces to <span class="inlinecode"><span class="id" type="var">n</span></span> no matter what <span class="inlinecode"><span class="id" type="var">n</span></span> is, a
    fact that can be read directly off the definition of <span class="inlinecode"><span class="id" type="var">plus</span></span>.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_O_n</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(<i>Note</i>: You may notice that the above statement looks
    different in the original source file and the final html output. In Coq
    files, we write the <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> universal quantifier using the
    "<i>forall</i>" reserved identifier. This gets printed as an
    upside-down "A", the familiar symbol used in logic.)  
<div class="paragraph"> </div>

 This is a good place to mention that <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> is
    actually more powerful than it might look at first sight. In the
    previous examples, the calls to <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> were actually not needed,
    because <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> can perform some simplification
    automatically when checking that two sides are equal; <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> was
    just added for explanation purposes. For instance, here is another
    proof of the same theorem: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_O_n'</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As a matter of fact, it will be useful later to know that
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> actually does somewhat more simplification than
    <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> does &mdash; for example, it tries "unfolding" defined terms,
    replacing them with their right-hand sides.  The reason for this
    difference is that, when reflexivity succeeds, the whole goal is
    finished and we don't need to look at whatever expanded
    expressions <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> has found; by contrast, <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> is used
    in situations where we may have to read and understand the new
    goal, so we would not want it blindly expanding definitions. 
<div class="paragraph"> </div>

 The form of the theorem we just stated and its proof are
    almost exactly the same as the examples above; there are just a
    few differences.

<div class="paragraph"> </div>

    First, we've used the keyword <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> instead of
    <span class="inlinecode"><span class="id" type="keyword">Example</span></span>.  Indeed, the difference is purely a matter of
    style; the keywords <span class="inlinecode"><span class="id" type="keyword">Example</span></span> and <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> (and a few others,
    including <span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>, <span class="inlinecode"><span class="id" type="keyword">Fact</span></span>, and <span class="inlinecode"><span class="id" type="keyword">Remark</span></span>) mean exactly the same
    thing to Coq.

<div class="paragraph"> </div>

    Second, we've added the quantifier <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>:<span class="id" type="var">nat</span></span>, so that our
    theorem talks about <i>all</i> natural numbers <span class="inlinecode"><span class="id" type="var">n</span></span>.  In order to prove
    theorems of this form, we need to to be able to reason by
    <i>assuming</i> the existence of an arbitrary natural number <span class="inlinecode"><span class="id" type="var">n</span></span>.  This
    is achieved in the proof by <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>, which moves the quantifier
    from the goal to a "context" of current assumptions. In effect, we
    start the proof by saying "OK, suppose <span class="inlinecode"><span class="id" type="var">n</span></span> is some arbitrary number."

<div class="paragraph"> </div>

    The keywords <span class="inlinecode"><span class="id" type="tactic">intros</span></span>, <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>, and <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> are examples of
    <i>tactics</i>.  A tactic is a command that is used between <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> and
    <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> to tell Coq how it should check the correctness of some
    claim we are making.  We will see several more tactics in the rest
    of this lecture, and yet more in future lectures.

<div class="paragraph"> </div>

    Other similar theorems can be proved with the same pattern. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_l</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 1 + <span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_0_l</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 0 × <span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">_l</span></span> suffix in the names of these theorems is
    pronounced "on the left." 
<div class="paragraph"> </div>

 It is worth stepping through these proofs to observe how the
context and the goal change.  You may want to add calls to <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> before <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> to
see the simplifications that Coq performs on the terms before checking
that they are equal. 
<div class="paragraph"> </div>

 Finally, we should mention that, although powerful enough to
    prove some fairly general facts, there are many statements that
    cannot be handled by simplification alone. For instance, perhaps
    surprisingly, we cannot use it to prove that <span class="inlinecode">0</span> is also a
    "neutral element" for <span class="inlinecode">+</span> <i>on the right</i>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_n_O</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">n</span> + 0 = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Doesn't&nbsp;do&nbsp;anything!&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
(Can you explain why this happens?  Step through both proofs
    with Coq and notice how the goal and context change.)

<div class="paragraph"> </div>

    When stuck in the middle of a proof, we can use the <span class="inlinecode"><span class="id" type="keyword">Abort</span></span>
    command to give up on it momentarily. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
In the next chapter, we cover a technique that can be used
for proving this goal. 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h1 class="section">Proof by Rewriting</h1>

<div class="paragraph"> </div>

 Here is a slightly more interesting theorem: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_example</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Instead of making a completely universal claim about all numbers
    <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>, this theorem talks about a more specialized property
    that only holds when <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.  The arrow symbol is pronounced
    "implies."

<div class="paragraph"> </div>

    As before, we need to be able to reason by assuming the existence
    of some numbers <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>.  We also need to assume the hypothesis
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>. The <span class="inlinecode"><span class="id" type="tactic">intros</span></span> tactic will serve to move all three of these
    from the goal into assumptions in the current context. 

<div class="paragraph"> </div>

    Since <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> are arbitrary numbers, we can't just use
    simplification to prove this theorem.  Instead, we prove it by
    observing that, if we are assuming <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, then we can replace
    <span class="inlinecode"><span class="id" type="var">n</span></span> with <span class="inlinecode"><span class="id" type="var">m</span></span> in the goal statement and obtain an equality with the
    same expression on both sides.  The tactic that tells Coq to
    perform this replacement is called <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;move&nbsp;both&nbsp;quantifiers&nbsp;into&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;move&nbsp;the&nbsp;hypothesis&nbsp;into&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;rewrite&nbsp;the&nbsp;goal&nbsp;using&nbsp;the&nbsp;hypothesis&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The first line of the proof moves the universally quantified
    variables <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> into the context.  The second moves the
    hypothesis <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> into the context and gives it the (arbitrary)
    name <span class="inlinecode"><span class="id" type="var">H</span></span>.  The third tells Coq to rewrite the current goal (<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>) by replacing the left side of the equality hypothesis
    <span class="inlinecode"><span class="id" type="var">H</span></span> with the right side.

<div class="paragraph"> </div>

    (The arrow symbol in the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> has nothing to do with
    implication: it tells Coq to apply the rewrite from left to right.
    To rewrite from right to left, you can use <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span style="font-family: arial;">&larr;</span></span>.  Try
    making this change in the above proof and see what difference it
    makes in Coq's behavior.) 
<div class="paragraph"> </div>

<a name="lab29"></a><h4 class="section">Exercise: 1 star (plus_id_exercise)</h4>
 Remove "<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>" and fill in the proof. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_exercise</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">m</span> = <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 As we've seen in earlier examples, the <span class="inlinecode"><span class="id" type="var">Admitted</span></span> command
    tells Coq that we want to skip trying to prove this theorem and
    just accept it as a given.  This can be useful for developing
    longer proofs, since we can state subsidiary facts that we believe
    will be useful for making some larger argument, use <span class="inlinecode"><span class="id" type="var">Admitted</span></span> to
    accept them on faith for the moment, and continue thinking about
    the larger argument until we are sure it makes sense; then we can
    go back and fill in the proofs we skipped.  Be careful, though:
    every time you say <span class="inlinecode"><span class="id" type="var">Admitted</span></span> (or <span class="inlinecode"><span class="id" type="var">admit</span></span>) you are leaving a door
    open for total nonsense to enter Coq's nice, rigorous, formally
    checked world! 
<div class="paragraph"> </div>

 We can also use the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> tactic with a previously proved
    theorem instead of a hypothesis from the context. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_0_plus</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" type="var">n</span>) × <span class="id" type="var">m</span> = <span class="id" type="var">n</span> × <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">plus_O_n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h4 class="section">Exercise: 2 stars (mult_S_1)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_S_1</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> × (1 + <span class="id" type="var">n</span>) = <span class="id" type="var">m</span> × <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h1 class="section">Proof by Case Analysis</h1>

<div class="paragraph"> </div>

 Of course, not everything can be proved by simple
    calculation: In general, unknown, hypothetical values (arbitrary
    numbers, booleans, lists, etc.) can block the calculation.  
    For example, if we try to prove the following fact using the 
    <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> tactic as above, we get stuck. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0_firsttry</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;does&nbsp;nothing!&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The reason for this is that the definitions of both
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> and <span class="inlinecode">+</span> begin by performing a <span class="inlinecode"><span class="id" type="keyword">match</span></span> on their first
    argument.  But here, the first argument to <span class="inlinecode">+</span> is the unknown
    number <span class="inlinecode"><span class="id" type="var">n</span></span> and the argument to <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> is the compound
    expression <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>; neither can be simplified.

<div class="paragraph"> </div>

    What we need is to be able to consider the possible forms of <span class="inlinecode"><span class="id" type="var">n</span></span>
    separately.  If <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">O</span></span>, then we can calculate the final result
    of <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> and check that it is, indeed, <span class="inlinecode"><span class="id" type="var">false</span></span>.
    And if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, then, although we don't know
    exactly what number <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> yields, we can calculate that, at
    least, it will begin with one <span class="inlinecode"><span class="id" type="var">S</span></span>, and this is enough to calculate
    that, again, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> will yield <span class="inlinecode"><span class="id" type="var">false</span></span>.

<div class="paragraph"> </div>

    The tactic that tells Coq to consider, separately, the cases where
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span> and where <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> is called <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> generates <i>two</i> subgoals, which we must then
    prove, separately, in order to get Coq to accept the theorem as
    proved. The annotation "<span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" type="var">n'</span>]</span>" is called an <i>intro pattern</i>.
    It tells Coq what variable names to introduce in each subgoal.  In
    general, what goes between the square brackets is a <i>list</i> of
    lists of names, separated by <span class="inlinecode">|</span>.  Here, the first component is
    empty, since the <span class="inlinecode"><span class="id" type="var">O</span></span> constructor is nullary (it doesn't carry any
    data).  The second component gives a single name, <span class="inlinecode"><span class="id" type="var">n'</span></span>, since <span class="inlinecode"><span class="id" type="var">S</span></span>
    is a unary constructor.

<div class="paragraph"> </div>

    The <span class="inlinecode">-</span> signs on the second and third lines are called <i>bullets</i>,
    and delimit parts of the proof that correspond to each generated
    subgoal. The code that comes after a bullet is the entire proof
    for a subgoal. In this example, each of the subgoals is easily
    proved by a single use of <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> (which itself performs
    some simplification, as usual &mdash; e.g., the first one simplifies
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> to <span class="inlinecode"><span class="id" type="var">false</span></span> by first rewriting <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>
    to <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span>, then unfolding <span class="inlinecode"><span class="id" type="var">beq_nat</span></span>, and then simplifying
    the <span class="inlinecode"><span class="id" type="keyword">match</span></span>).

<div class="paragraph"> </div>

    Marking cases with bullets is entirely optional: if they are not
    present, Coq simply asks you to prove each subgoal in sequence,
    one at a time. Even so, it is a good idea to use bullets, mainly
    for two reasons. First, they make the structure of a proof more
    apparent, making it more readable. Second, bullets instruct Coq to
    ensure that a subgoal is complete before trying to verify the next
    one, preventing proofs for different subgoals from getting mixed
    up. These issues become especially important in large
    developments, where fragile proofs lead to long debugging sessions.

<div class="paragraph"> </div>

    There are no hard and fast rules for how proofs should be
    formatted in Coq &mdash; in particular, where lines should be broken
    and how sections of the proof should be indented to indicate their
    nested structure.  However, if the places where multiple subgoals
    are generated are marked with explicit bullets placed at the
    beginning of lines, then the proof will be readable almost no
    matter what choices are made about other aspects of layout.

<div class="paragraph"> </div>

    This is a good place to mention one other piece of (possibly
    obvious) advice about line lengths.  Beginning Coq users sometimes
    tend to the extremes, either writing each tactic on its own line
    or entire proofs on one line.  Good style lies somewhere in the
    middle.  In particular, one reasonable convention is to limit
    yourself to 80-character lines.  Lines longer than this are hard
    to read and can be inconvenient to display and print.  Many
    editors have features that help enforce this.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic can be used with any inductively defined
    datatype.  For example, we use it here to prove that boolean
    negation is involutive &mdash; i.e., that negation is its own
    inverse. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">negb_involutive</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">negb</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> here has no <span class="inlinecode"><span class="id" type="keyword">as</span></span> clause because
    none of the subcases of the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> need to bind any variables,
    so there is no need to specify any names.  (We could also have
    written <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[|]</span>, or <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[]</span>.)  In fact, we can omit the <span class="inlinecode"><span class="id" type="keyword">as</span></span>
    clause from <i>any</i> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> and Coq will fill in variable names
    automatically.  Although this is convenient, it is arguably bad
    style, since Coq often makes confusing choices of names when left
    to its own devices. 

<div class="paragraph"> </div>

    It is possible to invoke <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> inside a subgoal, generating
    yet more proof obligations. In this case, we use different bullets
    to mark goals on different "levels." For example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_commutative</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>, <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">andb</span> <span class="id" type="var">c</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here, each pair of calls to <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> corresponds to
    subgoals that were generated after the execution of the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>
    <span class="inlinecode"><span class="id" type="var">c</span></span> line right above it. Using <span class="inlinecode">+</span> instead of <span class="inlinecode">-</span> for these
    subgoals allows Coq to distinguish between different levels of
    subgoals generated in a proof, making it more robust. Besides <span class="inlinecode">-</span>
    and <span class="inlinecode">+</span>, Coq proofs can also use <span class="inlinecode">×</span> as a third kind of bullet. If
    we encounter a proof that generates more than three levels of
    subgoals, we can also enclose individual subgoals with curly
    braces (<span class="inlinecode">{</span> <span class="inlinecode">...</span> <span class="inlinecode">}</span>): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_commutative'</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>, <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">andb</span> <span class="id" type="var">c</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. } }<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">reflexivity</span>. } }<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since curly braces mark both the beginning and the end of a
    proof, they can appear on multiple subgoal levels at the same
    time, as this example shows. Furthermore, curly braces allow us to
    reuse the same bullet shapes at multiple levels in a proof: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb3_exchange</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span>, <span class="id" type="var">andb</span> (<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) <span class="id" type="var">d</span> = <span class="id" type="var">andb</span> (<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">d</span>) <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">destruct</span> <span class="id" type="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>. }<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h4 class="section">Exercise: 2 stars (andb_true_elim2)</h4>
 Prove <span class="inlinecode"><span class="id" type="var">andb_true_elim2</span></span>, marking cases (and subcases) with bullets
    when you use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_true_elim2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab33"></a><h4 class="section">Exercise: 1 star (zero_nbeq_plus_1)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">zero_nbeq_plus_1</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> 0 (<span class="id" type="var">n</span> + 1) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab34"></a><h1 class="section">More Exercises</h1>

<div class="paragraph"> </div>

<a name="lab35"></a><h4 class="section">Exercise: 2 stars (boolean_functions)</h4>
 Use the tactics you have learned so far to prove the following 
    theorem about boolean functions. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">identity_fn_applied_twice</span> : <br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">f</span> : <span class="id" type="var">bool</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>), <br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">x</span> : <span class="id" type="var">bool</span>), <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>), <span class="id" type="var">f</span> (<span class="id" type="var">f</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now state and prove a theorem <span class="inlinecode"><span class="id" type="var">negation_fn_applied_twice</span></span> similar
    to the previous one but where the second hypothesis says that the
    function <span class="inlinecode"><span class="id" type="var">f</span></span> has the property that <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">negb</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>.
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab36"></a><h4 class="section">Exercise: 2 stars (andb_eq_orb)</h4>
 Prove the following theorem.  (You may want to first prove a
    subsidiary lemma or two. Alternatively, remember that you do
    not have to introduce all hypotheses at the same time.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_eq_orb</span> : <br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">b</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">orb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> = <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab37"></a><h4 class="section">Exercise: 3 stars (binary)</h4>
 Consider a different, more efficient representation of natural
    numbers using a binary rather than unary system.  That is, instead
    of saying that each natural number is either zero or the successor
    of a natural number, we can say that each binary number is either

<div class="paragraph"> </div>

<ul class="doclist">
<li> zero,

</li>
<li> twice a binary number, or

</li>
<li> one more than twice a binary number.

</li>
</ul>

<div class="paragraph"> </div>

    (a) First, write an inductive definition of the type <span class="inlinecode"><span class="id" type="var">bin</span></span>
        corresponding to this description of binary numbers. 

<div class="paragraph"> </div>

    (Hint: Recall that the definition of <span class="inlinecode"><span class="id" type="var">nat</span></span> from class,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">O</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">S</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">nat</span>.
<div class="paragraph"> </div>

</div>
    says nothing about what <span class="inlinecode"><span class="id" type="var">O</span></span> and <span class="inlinecode"><span class="id" type="var">S</span></span> "mean."  It just says "<span class="inlinecode"><span class="id" type="var">O</span></span> is
    in the set called <span class="inlinecode"><span class="id" type="var">nat</span></span>, and if <span class="inlinecode"><span class="id" type="var">n</span></span> is in the set then so is <span class="inlinecode"><span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">n</span></span>."  The interpretation of <span class="inlinecode"><span class="id" type="var">O</span></span> as zero and <span class="inlinecode"><span class="id" type="var">S</span></span> as successor/plus
    one comes from the way that we <i>use</i> <span class="inlinecode"><span class="id" type="var">nat</span></span> values, by writing
    functions to do things with them, proving things about them, and
    so on.  Your definition of <span class="inlinecode"><span class="id" type="var">bin</span></span> should be correspondingly simple;
    it is the functions you will write next that will give it
    mathematical meaning.)

<div class="paragraph"> </div>

    (b) Next, write an increment function <span class="inlinecode"><span class="id" type="var">incr</span></span> for binary numbers, 
        and a function <span class="inlinecode"><span class="id" type="var">bin_to_nat</span></span> to convert binary numbers to unary numbers.

<div class="paragraph"> </div>

    (c) Write five unit tests <span class="inlinecode"><span class="id" type="var">test_bin_incr1</span></span>, <span class="inlinecode"><span class="id" type="var">test_bin_incr2</span></span>, etc.
        for your increment and binary-to-unary functions. Notice that 
        incrementing a binary number and then converting it to unary 
        should yield the same result as first converting it to unary and 
        then incrementing. 

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab38"></a><h1 class="section">More on Notation (Advanced)</h1>

<div class="paragraph"> </div>

 In general, sections marked Advanced are not needed to follow the
    rest of the book, except possibly other Advanced sections.  On a
    first reading, you might want to skim these sections so that you
    know what's there for future reference. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x + y" := (<span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x × y" := (<span class="id" type="var">mult</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 40, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>

<br/>
</div>

<div class="doc">
For each notation symbol in Coq, we can specify its <i>precedence
    level</i> and its <i>associativity</i>.  The precedence level <span class="inlinecode"><span class="id" type="var">n</span></span> is
    specified by writing <span class="inlinecode"><span class="id" type="tactic">at</span></span> <span class="inlinecode"><span class="id" type="var">level</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>; this helps Coq parse compound
    expressions.  The associativity setting helps to disambiguate
    expressions containing multiple occurrences of the same
    symbol. For example, the parameters specified above for <span class="inlinecode">+</span> and
    <span class="inlinecode">×</span> say that the expression <span class="inlinecode">1+2×3×4</span> is shorthand for
    <span class="inlinecode">(1+((2×3)×4))</span>. Coq uses precedence levels from 0 to 100, and
    <i>left</i>, <i>right</i>, or <i>no</i> associativity.

<div class="paragraph"> </div>

    Each notation symbol is also associated with a <i>notation scope</i>.
    Coq tries to guess what scope you mean from context, so when you
    write <span class="inlinecode"><span class="id" type="var">S</span>(<span class="id" type="var">O</span>×<span class="id" type="var">O</span>)</span> it guesses <span class="inlinecode"><span class="id" type="var">nat_scope</span></span>, but when you write the
    cartesian product (tuple) type <span class="inlinecode"><span class="id" type="var">bool</span>×<span class="id" type="var">bool</span></span> it guesses
    <span class="inlinecode"><span class="id" type="var">type_scope</span></span>.  Occasionally, you may have to help it out with
    percent-notation by writing <span class="inlinecode">(<span class="id" type="var">x</span>×<span class="id" type="var">y</span>)%<span class="id" type="var">nat</span></span>, and sometimes in Coq's
    feedback to you it will use <span class="inlinecode">%<span class="id" type="var">nat</span></span> to indicate what scope a
    notation is in.

<div class="paragraph"> </div>

    Notation scopes also apply to numeral notation (<span class="inlinecode">3</span>, <span class="inlinecode">4</span>, <span class="inlinecode">5</span>,
    etc.), so you may sometimes see <span class="inlinecode">0%<span class="id" type="var">nat</span></span>, which means <span class="inlinecode"><span class="id" type="var">O</span></span> (the
    natural number <span class="inlinecode">0</span> that we're using in this chapter), or <span class="inlinecode">0%<span class="id" type="var">Z</span></span>
    which means the Integer zero (which comes from a different part of
    the standard library). 
<div class="paragraph"> </div>

<a name="lab39"></a><h1 class="section"><span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> and Structural Recursion (Advanced)</h1>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">plus'</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">S</span> (<span class="id" type="var">plus'</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
When Coq checks this definition, it notes that <span class="inlinecode"><span class="id" type="var">plus'</span></span> is
    "decreasing on 1st argument."  What this means is that we are
    performing a <i>structural recursion</i> over the argument <span class="inlinecode"><span class="id" type="var">n</span></span> &mdash; i.e.,
    that we make recursive calls only on strictly smaller values of
    <span class="inlinecode"><span class="id" type="var">n</span></span>.  This implies that all calls to <span class="inlinecode"><span class="id" type="var">plus'</span></span> will eventually
    terminate.  Coq demands that some argument of <i>every</i> <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>
    definition is "decreasing."

<div class="paragraph"> </div>

    This requirement is a fundamental feature of Coq's design: In
    particular, it guarantees that every function that can be defined
    in Coq will terminate on all inputs.  However, because Coq's
    "decreasing analysis" is not very sophisticated, it is sometimes
    necessary to write functions in slightly unnatural ways. 
<div class="paragraph"> </div>

<a name="lab40"></a><h4 class="section">Exercise: 2 stars, optional (decreasing)</h4>
 To get a concrete sense of this, find a way to write a sensible
    <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> definition (of a simple function on numbers, say) that
    <i>does</i> terminate on all inputs, but that Coq will reject because
    of this restriction. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

  
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>